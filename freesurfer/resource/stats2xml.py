#!/usr/bin/env python

# Created 2014-09-30, Jordi Huguet, Dept. Radiology AMC Amsterdam

####################################
__author__      = 'Jordi Huguet'  ##
__dateCreated__ = '20140930'      ##
__version__     = '0.8'           ##
__versionDate__ = '20160928'      ##
####################################

# TO DO:
# - ...

import os
import sys
from lxml import etree
from datetime import datetime
from pprint import pprint
# homebrewed parser module (statsParser.py)
import statsParser


def createXMLHeader(namespace, main_object_id):
    ''' Helper for composing the header of an XML element containing the XNAT output data '''
    ''' Returns a long string element'''
    
    # Start printing the XML document.
    xmlHeader_preamble = '<?xml version="1.0" encoding="UTF-8"?>\n'
    xmlHeader_preamble += '<!-- XNAT XML generated by %s - %s on %s -->' %(os.path.basename(sys.argv[0]),__author__,str(datetime.now().replace(microsecond=0)))
    xmlHeader_start = ( '<'+namespace+ ':' + main_object_id+' '
                        'xmlns:'+namespace+'="http://nrg.wustl.edu/'+namespace+'" ' 
                        'xmlns:xnat="http://nrg.wustl.edu/xnat" ' 
                        'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' )
                        #'xsi:schemaLocation= ...">' )
    xmlHeader_end = '</'+namespace+ ':' + main_object_id+'>'
    
    xml_header = xmlHeader_preamble + '\n' + xmlHeader_start + '\n' + xmlHeader_end
    
    return xml_header
    
    
def populateVolXML(xmlElement,asegData):	
	''' Fill-in an XML subelement with subcortical segmentation (asec.stats) output file content '''	
	''' Returns an XML element'''
	
	globalStatsList = ['ICV', 'lhCortexVol', 'rhCortexVol', 'CortexVol', 'SubCortGrayVol', 'TotalGrayVol', 'SupraTentorialVol', 'lhCorticalWhiteMatterVol', 'rhCorticalWhiteMatterVol', 'CorticalWhiteMatterVol']
	
	structStatsList = ['NVoxels', 'Volume', 'rhCortexVol', 'normMean', 'normStdDev', 'normMin', 'normMax', 'normRange']
	
	globalMeasures = asegData.globalMeasures
	# Specific case, mismatching naming convention
	if 'etiv' in globalMeasures.keys() :
		globalMeasures['icv'] = globalMeasures.pop('etiv')
	
	# Add global brain volume stats 
	for gMeasure in globalStatsList :
			if gMeasure.lower() in globalMeasures.keys() :
				sElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}%s" %gMeasure)
				sElem.text = globalMeasures[gMeasure.lower()]
				
	structureStats = asegData.structures
	# Specific case, mismatching naming convention (XML schema VS FreeSurfer stats file)
	structureStats['headers'] = [struct.replace('Volume_mm3', 'Volume') for struct in structureStats['headers']]
	
	structsXMLElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}structures")
	
	# Add segmented structures and their volumetric measures
	# Pull out headers
	headerList = structureStats.pop('headers')		
	for structure in structureStats :
		#Create a dictionary merging headers and structure values lists
		structDictionary = dict(zip(headerList, structureStats[structure]))
		#Create the structure XML element
		structXMLElem = etree.SubElement(structsXMLElem, "{http://nrg.wustl.edu/AMCZ0}structure", name="%s" %structDictionary['StructName'], SegId='%s' %structDictionary['SegId'])	
		for structMeasure in structDictionary :
			# Add only the subset of attributes per structure we want to keep/archive, discard the rest
			if structMeasure in structStatsList :
				sElem = etree.SubElement(structXMLElem, "{http://nrg.wustl.edu/AMCZ0}%s" %structMeasure)
				sElem.text = structDictionary[structMeasure]				
	
	return xmlElement
	
def populateSurfXML(xmlElement,lh_aparcData,rh_aparcData):	
	''' Fill in an XML subelement with statistical output content of the cortical parcellation (lh.aparc.stats and rh.aparc.stats) '''
	''' Returns an XML element'''
	
	# Add  brain surface stats per each hemisphere
	lhXMLElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}hemisphere", name='left')
	lhXMLElem = populateHemisphereXML(lhXMLElem,lh_aparcData)
	
	rhXMLElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}hemisphere", name='right')
	lhXMLElem = populateHemisphereXML(rhXMLElem,rh_aparcData)
	
	return xmlElement
	
def populateHemisphereXML(xmlElement, aparcData) :
	''' Populates an hemispheric XML subelement with cortical parcellation data (lh.aparc.stats and rh.aparc.stats) '''
	''' Returns an XML element'''
		
	globalStatsList = ['NumVert', 'SurfArea', 'MeanThickness']
	
	regionStatsList = ['NumVert', 'SurfArea', 'GrayVol', 'ThickAvg', 'ThickStd', 'MeanCurv', 'GausCurv', 'FoldInd', 'CurvInd']
	
	globalMeasures = aparcData.globalMeasures
	# Specific case, mismatching naming convention
	if 'whitesurfarea' in globalMeasures.keys() :
		globalMeasures['surfarea'] = globalMeasures.pop('whitesurfarea')
	
	# Add global brain volume stats 
	for gMeasure in globalStatsList :
			if gMeasure.lower() in globalMeasures.keys() :
				sElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}%s" %gMeasure)
				sElem.text = globalMeasures[gMeasure.lower()]				
	
	regionStats = aparcData.structures
	regionsXMLElem = etree.SubElement(xmlElement, "{http://nrg.wustl.edu/AMCZ0}regions")
	
	# Add segmented regions and their surface measures
	# Pull out headers
	headerList = regionStats.pop('headers')		
	for region in regionStats :		
		# Create a dictionary merging headers and region values lists
		regionDictionary = dict(zip(headerList, regionStats[region]))
		#Create the region XML element
		regionXMLElem = etree.SubElement(regionsXMLElem, "{http://nrg.wustl.edu/AMCZ0}region", name="%s" %regionDictionary['StructName'])	
		for regionMeasure in regionDictionary :
			# Add only the subset of attributes per region we want to keep/archive, discard the rest
			if regionMeasure in regionStatsList :
				sElem = etree.SubElement(regionXMLElem, "{http://nrg.wustl.edu/AMCZ0}%s" %regionMeasure)
				sElem.text = regionDictionary[regionMeasure]
	
	return xmlElement
	
def createXML(asegData,lh_aparcData,rh_aparcData):
	''' Main function for the creation of the XNAT-compliant XML object '''
	''' Returns an XML root element populated with all freesurfer data '''
	namespace,datatype_id = FS_TYPE.split(':')
	xmlHdr = createXMLHeader(namespace,datatype_id)
	rootXMLElem = etree.fromstring(xmlHdr)
	
	# TO-DO :: use Freesurder output files datetime instead of current datetime!
	date = etree.SubElement(rootXMLElem, "{http://nrg.wustl.edu/xnat}date")
	date.text = str(datetime.now().date())
	
	time = etree.SubElement(rootXMLElem, "{http://nrg.wustl.edu/xnat}time")
	time.text = str(datetime.now().replace(microsecond=0).time())
	
	measuresXMLElem = etree.SubElement(rootXMLElem, "{http://nrg.wustl.edu/AMCZ0}measures")	
	
	# Create the volumetric data block
	volumetricXMLElem = etree.SubElement(measuresXMLElem, "{http://nrg.wustl.edu/AMCZ0}volumetric")
	volumetricXMLElem = populateVolXML(volumetricXMLElem,asegData)
	
	# Create the surface data block
	surfaceXMLElem = etree.SubElement(measuresXMLElem, "{http://nrg.wustl.edu/AMCZ0}surface")
	surfaceXMLElem = populateSurfXML(surfaceXMLElem,lh_aparcData,rh_aparcData)
	
	return rootXMLElem	
	
def parseStatsFile(fsStatsFileName,fsStatsDir):
	''' Given an ASCII stats file from FreeSurfer output (aseg/aparc stats), parses the file's statistical values'''
	''' StatsParser script is used for the parsing of the files '''
	''' Returns a FileStats class instance with all parsed FreeSurfer data '''
	
	# Create the dict containing the parsed mesures
	measureDict = {}
	
	# Check if stats file existis in the directory context 
	file = os.path.join(fsStatsDir, fsStatsFileName)
	if not os.path.exists(file) :
		raise Exception('File (%s) not found' %file)		
	else: 
		try:
			# Parse the ASCII stats file and pull all measure/structure values contained
			parsedFile = statsParser.parseFile(file)										
		except Exception as e:
			# Just dump exception message and quit
			raise Exception('Unable to parse stats file (%s). Reason: %s' %(file,e))					
		
	return parsedFile


def main (workingDir,outFileName):
	''' Main function -> workingDir is the location where FreeSurfer output should be located: a directory with the subject Name/ID'''
	''' stats2xml will look for a stats subdirectory where to parse FreeSurfer mesures out of them and populate then an XNAT-compliant XML object'''
	''' outFileName is the absolute path and filename where stats2xml will save output XML object'''
	
	try:
		#Early checkings for input directory and parameters
		if not os.path.exists(workingDir) :
			raise Exception('No access to given directory: %s' %workingDir)		
		
		#Search recursively for the stats subdirectory in the workingDir directory tree
		fsStatsRoot = None
		for root,dirs,files in os.walk(os.path.abspath(workingDir)):							
			if 'stats' in dirs:
				fsStatsRoot = root
				break

		#Double check the consistency of the input stats directory and output file name 
		fsStatsDir	= os.path.join(fsStatsRoot,'stats')
		if not os.path.exists(fsStatsDir):					
			raise Exception('Unable to access stats subdirectory in %s' %workingDir)
		
		if os.path.exists(outFileName) :
			raise Exception('File (%s) already exists' %outFileName)		
		
		#If all OK, parse the stats files aseg and aparc x each hemisphere
		asegData = parseStatsFile('aseg.stats',fsStatsDir)
		lhaparcData = parseStatsFile('lh.aparc.stats',fsStatsDir)
		rhaparcData = parseStatsFile('rh.aparc.stats',fsStatsDir)
		
		#Given the parsed metadata, compose an XML object compliant with the XNAT schema for FreeSurfer outputs
		xml = createXML(asegData,lhaparcData,rhaparcData)		
		
		#Save the XML object in a file @ parent directory => os.path.dirname(workingDir)
		xmlDoc = etree.ElementTree(xml)
		outFile = open(outFileName, 'w')
		xmlDoc.write(outFile, xml_declaration=True, encoding='UTF-8') 
	
	except Exception as e:
		# Just dump exception message and quit
		print '[Error]',e					
	
	return
	
	
###													###
# Top-level script environment			         	  #
###													###
if __name__=="__main__" :
	print ''
	
	#Let's specify the FreeSurfer data-type as XML type
	FS_TYPE = 'AMCZ0:freesurfer'
		
	if len(sys.argv) != 3 :
		print '%s <working_directory> <output_filename>' %(os.path.basename(sys.argv[0]))
	else : 
		main(sys.argv[1],sys.argv[2])